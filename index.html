<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>fu-n.net</title>
    <style>
        @font-face {
            font-family: 'MSPGothic';
            src: local('MS PGothic'), local('MS Pゴシック'), local('MS PGothic'), local('MSPGothic'), local('sans-serif');
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'MSPGothic', sans-serif;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background: #000000;
            position: relative;
        }

        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            display: none; /* 初期状態では非表示 */
        }

        #characterCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3; /* 煙エフェクトとASCIIロゴの上 */
            pointer-events: auto; /* マウスイベントを受け取れるようにする */
            cursor: pointer; /* カーソルをポインターに変更 */
        }

        /* CSS煙エフェクト */
        .smoke-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            z-index: 0;
            overflow: hidden;
        }

        .smoke-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-repeat: repeat-x;
            pointer-events: none;
        }

        /* 第1レイヤー - シアン */
        .smoke-layer-1 {
            background-image: radial-gradient(
                circle at center,
                rgba(0, 255, 255, 0.15) 0%,
                rgba(170, 0, 255, 0.1) 40%,
                rgba(0, 0, 0, 0) 70%
            );
            background-size: 100% 300%; /* サイズを10倍程度に拡大 */
            animation: smokeFlow1 60s linear infinite;
            opacity: 0.6;
        }

        /* 第2レイヤー - パープル */
        .smoke-layer-2 {
            top: 20%;
            background-image: radial-gradient(
                circle at center,
                rgba(170, 0, 255, 0.15) 0%,
                rgba(0, 255, 170, 0.08) 40%,
                rgba(0, 0, 0, 0) 70%
            );
            background-size: 80% 300%; /* サイズを10倍程度に拡大 */
            animation: smokeFlow2 45s linear infinite reverse;
            opacity: 0.5;
        }

        /* 第3レイヤー - グリーン */
        .smoke-layer-3 {
            top: 40%;
            background-image: radial-gradient(
                circle at center,
                rgba(0, 255, 170, 0.12) 0%,
                rgba(0, 150, 255, 0.06) 40%,
                rgba(0, 0, 0, 0) 70%
            );
            background-size: 120% 350%; /* サイズを10倍程度に拡大 */
            animation: smokeFlow3 70s linear infinite;
            opacity: 0.4;
        }

        /* アニメーション - 画面全体に広がるように */
        @keyframes smokeFlow1 {
            0% { transform: translateX(-100%) scale(1.2); }
            50% { transform: translateX(0%) scale(1.5); }
            100% { transform: translateX(100%) scale(1.2); }
        }

        @keyframes smokeFlow2 {
            0% { transform: translateX(50%) scale(1.5); }
            50% { transform: translateX(-50%) scale(1.8); }
            100% { transform: translateX(-150%) scale(1.5); }
        }

        @keyframes smokeFlow3 {
            0% { transform: translateX(-120%) scale(1.3); }
            50% { transform: translateX(0%) scale(1.6); }
            100% { transform: translateX(120%) scale(1.3); }
        }

        /* 光の点滅エフェクト - より大きく強力に */
        .light {
            position: absolute;
            border-radius: 50%;
            filter: blur(80px); /* より広範囲にぼかす */
            opacity: 0;
            pointer-events: none;
        }

        .light-cyan {
            width: 500px; /* より大きく */
            height: 500px;
            background: rgba(0, 255, 255, 0.25);
            left: 30%;
            top: 30%;
            animation: pulse-cyan 8s infinite alternate;
        }

        .light-purple {
            width: 600px; /* より大きく */
            height: 600px;
            background: rgba(170, 0, 255, 0.25);
            right: 20%;
            top: 50%;
            animation: pulse-purple 10s infinite alternate-reverse;
        }

        .light-green {
            width: 400px; /* より大きく */
            height: 400px;
            background: rgba(0, 255, 170, 0.25);
            left: 55%;
            top: 25%;
            animation: pulse-green 12s infinite alternate;
        }

        /* 追加の光源 */
        .light-white {
            width: 700px;
            height: 700px;
            background: rgba(255, 255, 255, 0.1);
            left: 45%;
            top: 40%;
            animation: pulse-white 15s infinite alternate;
        }

        @keyframes pulse-cyan {
            0% { opacity: 0.15; transform: scale(0.8) translate(-20px, -20px); }
            50% { opacity: 0.3; transform: scale(1.2) translate(40px, 10px); }
            100% { opacity: 0.25; transform: scale(1.0) translate(0px, 30px); }
        }

        @keyframes pulse-purple {
            0% { opacity: 0.15; transform: scale(0.9) translate(30px, 0px); }
            50% { opacity: 0.35; transform: scale(1.1) translate(-20px, 20px); }
            100% { opacity: 0.3; transform: scale(1.2) translate(10px, -30px); }
        }

        @keyframes pulse-green {
            0% { opacity: 0.15; transform: scale(0.7) translate(-30px, 20px); }
            50% { opacity: 0.25; transform: scale(1.3) translate(20px, -10px); }
            100% { opacity: 0.2; transform: scale(1.0) translate(10px, 0px); }
        }

        @keyframes pulse-white {
            0% { opacity: 0.05; transform: scale(0.6) translate(0px, 0px); }
            50% { opacity: 0.15; transform: scale(1.4) translate(10px, 10px); }
            100% { opacity: 0.1; transform: scale(1.0) translate(-10px, -10px); }
        }

        .container {
            text-align: center;
            display: flex;
            flex-direction: column;
            height: 100%;
            justify-content: center;
            align-items: center;
            width: 100%;
            position: relative;
            z-index: 2;
        }

        .ascii-logo {
            font-family: 'Consolas', monospace;
            font-size: 12pt;
            color: white;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.7);
            white-space: pre;
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            line-height: 1.2;
        }

        @media (max-height: 300px) {
            .ascii-logo, .social-link {
                display: none;
            }
        }

        .ascii-art {
            font-size: 12pt;
            color: white;
            text-shadow: 0 0 10px rgba(170, 0, 255, 0.7);
            white-space: nowrap;
            margin-bottom: 10px;
        }

        .social-link {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            color: white;
            text-decoration: none;
            font-size: 1.2rem;
            transition: all 0.3s ease;
            padding: 10px 20px;
            border-radius: 30px;
            background-color: rgba(0, 0, 0, 0.2);
            z-index: 2;
        }

        .social-link:hover {
            background-color: rgba(0, 0, 0, 0.4);
            transform: translateY(-3px);
        }

        .x-icon {
            width: 20px;
            height: 20px;
        }
    </style>
</head>
<body>
    <!-- CSS煙エフェクト（フォールバック） -->
    <div class="smoke-effect">
        <div class="smoke-layer smoke-layer-1"></div>
        <div class="smoke-layer smoke-layer-2"></div>
        <div class="smoke-layer smoke-layer-3"></div>
        <div class="light light-cyan"></div>
        <div class="light light-purple"></div>
        <div class="light light-green"></div>
        <div class="light light-white"></div>
    </div>

    <!-- WebGL用キャンバス -->
    <canvas id="canvas"></canvas>

    <!-- コンテンツ -->
    <div class="container">
        <pre class="ascii-logo">   __                                 _
  / _|                               | |
 | |_ _   _ ______ _ __    _ __   ___| |_
 |  _| | | |______| '_ \  | '_ \ / _ \ __|
 | | | |_| |      | | | |_| | | |  __/ |_
 |_|  \__,_|      |_| |_(_)_| |_|\___|\__|

                                          </pre>
    </div>

    <!-- キャラクターアニメーション用キャンバス -->
    <canvas id="characterCanvas"></canvas>

    <div style="position: fixed; bottom: 20px; left: 20px; z-index: 2;">
        <div class="ascii-art">（；´_ゝ`）ﾌｰﾝ</div>
        <a href="https://x.com/foontype" target="_blank" rel="noopener noreferrer" class="social-link">
            <svg class="x-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                <path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
            </svg>
            @foontype
        </a>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <!-- Fallback loader added directly-->
    <script>
    // Fallback definition of GLTFLoader if not loaded from CDN
    if (typeof GLTFLoader === 'undefined') {
        console.log('GLTFLoader not available from CDN, using fallback');
        // Since we can't define a full GLTFLoader here, we'll create a dummy
        // that will silently skip loading but not crash
        window.GLTFLoader = function() {
            this.load = function(url, onLoad, onProgress, onError) {
                console.log('Dummy GLTFLoader called for:', url);
                if (onError) onError(new Error('GLTFLoader not properly initialized'));
            };
        };
    }
    </script>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // WebGL関連の処理を試みる
            initWebGL();
            // キャラクターのアニメーション処理を初期化
            initCharacterAnimation();
        });

        function initWebGL() {
            // Three.jsはすでに読み込まれているのでそのまま初期化
            startThreeJS();
        }

        function startThreeJS() {
            try {
                // WebGLのサポートチェック
                if (!isWebGLAvailable()) {
                    console.log('WebGL非対応: CSSフォールバックを使用');
                    return;
                }

                // Three.js初期化
                let scene, camera, renderer;
                let clock = new THREE.Clock();
                let particles = [];
                let lights = [];

                // 設定
                const PARTICLE_COUNT = 10; // 数を10分の1に減らす
                const PARTICLE_SIZE_MIN = 15000; // さらに10倍大きく
                const PARTICLE_SIZE_MAX = 30000; // さらに10倍大きく

                // リサイズ処理
                function onWindowResize() {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                }

                // シーンの初期化
                function initScene() {
                    scene = new THREE.Scene();
                    camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 15000);
                    camera.position.z = 7000; // さらにカメラを遠ざけて巨大なパーティクルを表示

                    const canvas = document.getElementById('canvas');
                    renderer = new THREE.WebGLRenderer({
                        canvas: canvas,
                        antialias: false, // パフォーマンス優先
                        alpha: true,
                        powerPreference: 'default'
                    });

                    renderer.setSize(window.innerWidth, window.innerHeight);
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // 解像度制限

                    window.addEventListener('resize', onWindowResize, false);
                }

                // ライト初期化
                function initLights() {
                    // 青色のライト - 超巨大なパーティクルに合わせて調整
                    const blueLight = new THREE.PointLight(0x00FFFF, 25, 10000);
                    blueLight.position.set(2000, 1500, 3000);
                    scene.add(blueLight);
                    lights.push(blueLight);

                    // 紫色のライト - 超巨大なパーティクルに合わせて調整
                    const purpleLight = new THREE.PointLight(0xAA00FF, 25, 10000);
                    purpleLight.position.set(-2000, -1000, 2500);
                    scene.add(purpleLight);
                    lights.push(purpleLight);

                    // 緑色のライト - 超巨大なパーティクルに合わせて調整
                    const greenLight = new THREE.PointLight(0x00FFAA, 25, 10000);
                    greenLight.position.set(0, -2000, 2000);
                    scene.add(greenLight);
                    lights.push(greenLight);

                    // 追加: 白色のアンビエントライト - 全体を明るく
                    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
                    scene.add(ambientLight);

                    // 追加: 白色の方向光 - 煙のエッジを強調
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                    directionalLight.position.set(1, 1, 1).normalize();
                    scene.add(directionalLight);
                }

                // パーティクル初期化
                function initParticles() {
                    return new Promise((resolve, reject) => {
                        try {
                            // テクスチャ読み込み
                            const textureLoader = new THREE.TextureLoader();
                            let loadedTextures = 0;
                            let smokeTexture, normalTexture;

                            // 煙テクスチャ
                            textureLoader.load(
                                'res/smoke.png',
                                function(texture) {
                                    smokeTexture = texture;
                                    loadedTextures++;
                                    if (loadedTextures === 2) createParticles();
                                },
                                undefined,
                                function(error) {
                                    console.error('煙テクスチャ読み込み失敗:', error);
                                    reject(error);
                                }
                            );

                            // 法線マップ
                            textureLoader.load(
                                'res/smoke_normal.png',
                                function(texture) {
                                    normalTexture = texture;
                                    loadedTextures++;
                                    if (loadedTextures === 2) createParticles();
                                },
                                undefined,
                                function(error) {
                                    console.error('法線マップ読み込み失敗:', error);
                                    reject(error);
                                }
                            );

                            // パーティクル作成
                            function createParticles() {
                                // マテリアル - より反射率を高く、より滑らかに
                                //const particleMaterial = new THREE.MeshStandardMaterial({
                                //    map: smokeTexture,
                                //    normalMap: normalTexture,
                                //    transparent: true,
                                //    side: THREE.DoubleSide,
                                //    //alphaTest: 0.03,
                                //    metalness: 0.5, // より反射率を高く
                                //    roughness: 0.5, // より滑らかに
                                //    normalScale: new THREE.Vector2(1.5, 1.5) // 法線マップの効果を強化
                                //});

                                //const particleMaterial = new THREE.SpriteMaterial({
                                //    map: smokeTexture,
                                //    blending: THREE.AdditiveBlending,
                                //    transparent: true,
                                //    depthWrite: false
                                //});

                                const colors = [
                                  new THREE.Color(0xff0070), // ネオンピンク
                                  new THREE.Color(0xff00ff), // マゼンタ/紫
                                  new THREE.Color(0x00ffff), // シアン
                                  new THREE.Color(0x0080ff), // 電気青
                                  new THREE.Color(0xff3800), // サイバーオレンジ
                                  new THREE.Color(0x9000ff)  // ディープパープル
                                ];

                                const particleMaterial = new THREE.MeshBasicMaterial({
                                    map: smokeTexture,
                                    blending: THREE.AdditiveBlending,
                                    transparent: true,
                                    depthWrite: false,
                                    side: THREE.DoubleSide,
                                    alphaTest: 0.000001,
                                    color: colors[0],
                                });

                                // ジオメトリ
                                const particleGeometry = new THREE.PlaneGeometry(1, 1);

                                for (let i = 0; i < PARTICLE_COUNT; i++) {
                                    let material = particleMaterial.clone()

                                    material.color = colors[Math.floor(Math.random() * colors.length)];

                                    // メッシュ作成
                                    const particleMesh = new THREE.Mesh(particleGeometry, material);

                                    // 超巨大なパーティクルを画面全体に広がるよう配置
                                    const x = Math.random() * 35000 - 22000; // 左側に多く、右側にも少し
                                    const y = Math.random() * 10000 - 5000; // 画面上下に広く分布
                                    const z = Math.random() * 5 - 3; // 奥行きも広げる

                                    particleMesh.position.set(x, y, z);
                                    particleMesh.rotation.z = Math.random() * Math.PI * 2;

                                    // サイズをランダムに
                                    const size = Math.random() * (PARTICLE_SIZE_MAX - PARTICLE_SIZE_MIN) + PARTICLE_SIZE_MIN;
                                    particleMesh.scale.set(size, size, 1);

                                    // 移動速度など設定（超巨大なパーティクルのためにさらに速く）
                                    const speedX = Math.random() * 450 + 300; // 巨大なので速度も上げる
                                    const speedY = Math.random() * 30 - 15;  // Y方向の動きも強調
                                    const speedRotation = (Math.random() * 0.0007 - 0.0005); // 回転は遅めに

                                    const particle = {
                                        mesh: particleMesh,
                                        speedX: speedX,
                                        speedY: speedY,
                                        speedRotation: speedRotation,
                                        opacity: Math.random() * 1 + 0.85 // 大きなパーティクルなので不透明度を下げる
                                    };

                                    // 不透明度設定
                                    particleMesh.material.opacity = particle.opacity;

                                    // シーンに追加
                                    scene.add(particleMesh);
                                    particles.push(particle);
                                }

                                resolve();
                            }
                        } catch (error) {
                            console.error('パーティクル初期化エラー:', error);
                            reject(error);
                        }
                    });
                }

                // パーティクルアニメーション
                function animateParticles() {
                    const deltaTime = clock.getDelta();

                    particles.forEach(particle => {
                        // 移動
                        particle.mesh.position.x += particle.speedX * deltaTime;
                        particle.mesh.position.y += particle.speedY * deltaTime;

                        // 回転
                        particle.mesh.rotation.z += particle.speedRotation;

                        // 画面外に出たら反対側に戻す
                        if (particle.mesh.position.x > 10000) {
                            particle.mesh.position.x = Math.random() * -10000 - 10000; // 左側のランダムな位置に
                            particle.mesh.position.y = Math.random() * 10000 - 5000;  // 高さもランダムに再配置
                            particle.mesh.position.z = Math.random() * 4000 - 2000;   // 奥行きも再配置

                            // 不透明度リセット
                            particle.mesh.material.opacity = particle.opacity;

                            // カラーをランダムに設定
                            const colors = [
                                new THREE.Color(0xff0070), // ネオンピンク
                                new THREE.Color(0xff00ff), // マゼンタ/紫
                                new THREE.Color(0x00ffff), // シアン
                                new THREE.Color(0x0080ff), // 電気青
                                new THREE.Color(0xff3800), // サイバーオレンジ
                                new THREE.Color(0x9000ff)  // ディープパープル
                            ];
                            particle.mesh.material.color = colors[Math.floor(Math.random() * colors.length)];
                        }

                        // 画面端に近づくと徐々に透明に（左右両端）
                        const edgeFadeDistance = 2000; // フェード距離も拡大

                        if (particle.mesh.position.x > 6000) {
                            // 右端に近づくと透明に
                            const fadeOutFactor = 1 - (particle.mesh.position.x - 6000) / 2000;
                            particle.mesh.material.opacity = particle.opacity * Math.max(0, fadeOutFactor);
                        } else if (particle.mesh.position.x < -6000) {
                            // 左端に近づくと透明に
                            const fadeOutFactor = 1 - (Math.abs(particle.mesh.position.x) - 6000) / 2000;
                            particle.mesh.material.opacity = particle.opacity * Math.max(0, fadeOutFactor);
                        }
                    });
                }

                // ライトアニメーション
                function animateLights() {
                    const time = clock.getElapsedTime();

                    // 青色のライト - 超巨大な移動範囲と強度変化
                    lights[0].intensity = 20 + Math.sin(time * 0.7) * 10;
                    lights[0].position.x = 2000 + Math.sin(time * 0.2) * 1500;
                    lights[0].position.y = 1500 + Math.cos(time * 0.3) * 1000;
                    lights[0].position.z = 3000 + Math.sin(time * 0.25) * 500;

                    // 紫色のライト - 超巨大な移動範囲と強度変化
                    lights[1].intensity = 20 + Math.sin(time * 0.5) * 10;
                    lights[1].position.y = -1000 + Math.sin(time * 0.3) * 1200;
                    lights[1].position.x = -2000 + Math.cos(time * 0.4) * 1500;
                    lights[1].position.z = 2500 + Math.cos(time * 0.35) * 600;

                    // 緑色のライト - 超巨大な移動範囲と強度変化
                    lights[2].intensity = 20 + Math.sin(time * 0.6) * 10;
                    lights[2].position.z = 2000 + Math.sin(time * 0.45) * 800;
                    lights[2].position.x = Math.sin(time * 0.25) * 2000;
                    lights[2].position.y = -2000 + Math.cos(time * 0.35) * 1000;
                    lights[2].color.setHSL(0.3 + Math.sin(time * 0.2) * 0.15, 1, 0.5);
                }

                // アニメーションループ
                function animate() {
                    requestAnimationFrame(animate);

                    animateParticles();
                    animateLights(); // ライトアニメーションを有効化

                    renderer.render(scene, camera);
                }

                // WebGL対応チェック
                function isWebGLAvailable() {
                    try {
                        const canvas = document.createElement('canvas');
                        return !!(window.WebGLRenderingContext &&
                            (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));
                    } catch (e) {
                        console.error('WebGL非対応:', e);
                        return false;
                    }
                }

                // WebGL初期化成功時
                function enableWebGL() {
                    document.querySelector('.smoke-effect').style.display = 'none';
                    document.getElementById('canvas').style.display = 'block';
                }

                // メイン
                async function main() {
                    try {
                        initScene();
                        initLights(); // ライトを有効化
                        await initParticles();
                        enableWebGL();
                        animate();
                    } catch (error) {
                        console.error('Three.js初期化エラー:', error);
                    }
                }

                // 実行
                main();

            } catch (error) {
                console.error('致命的なエラー:', error);
            }
        }

        // キャラクターアニメーション機能
        function initCharacterAnimation() {
            try {
                // Check if GLTFLoader exists globally
                if (typeof GLTFLoader === 'undefined') {
                    console.log('GLTFLoaderが利用できません。キャラクターアニメーションをスキップします。');
                    return;
                }

                // シーン、カメラ、レンダラーの設定
                const characterScene = new THREE.Scene();
                const characterCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
                characterCamera.position.set(0, 2, 6);
                characterCamera.lookAt(0, 1, 0);

                const characterRenderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('characterCanvas'),
                    antialias: true,
                    alpha: true
                });
                characterRenderer.setSize(window.innerWidth, window.innerHeight);
                characterRenderer.setClearColor(0x000000, 0); // 透明な背景

                // サイバーカラーのライト設定
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
                characterScene.add(ambientLight);

                // サイバーカラーの複数ポイントライトを追加
                const cyberLights = [];

                // ネオンピンクライト
                const pinkLight = new THREE.PointLight(0xff0070, 1.5, 10);
                pinkLight.position.set(2, 1, 3);
                characterScene.add(pinkLight);
                cyberLights.push({light: pinkLight, baseColor: 0xff0070, hueOffset: 0});

                // シアンライト
                const cyanLight = new THREE.PointLight(0x00ffff, 1.5, 10);
                cyanLight.position.set(-2, 0, 3);
                characterScene.add(cyanLight);
                cyberLights.push({light: cyanLight, baseColor: 0x00ffff, hueOffset: 0.5});

                // 紫ライト
                const purpleLight = new THREE.PointLight(0x9000ff, 1.5, 10);
                purpleLight.position.set(0, 3, 2);
                characterScene.add(purpleLight);
                cyberLights.push({light: purpleLight, baseColor: 0x9000ff, hueOffset: 0.8});

                // アニメーション用変数
                let characterMixer;
                const characterClock = new THREE.Clock();
                let character;

                // キャラクターをクリッカブルにする
                const characterCanvas = document.getElementById('characterCanvas');
                characterCanvas.addEventListener('click', function() {
                    // キャラクターページに遷移
                    window.location.href = '/characters';
                });

                // ホバー時のエフェクト
                let isHovering = false;
                characterCanvas.addEventListener('mousemove', function() {
                    if (!character) return;
                    if (!isHovering) {
                        isHovering = true;
                        // ホバー時に軽く拡大する
                        character.scale.multiplyScalar(1.05);
                        // 輝度を上げる
                        cyberLights.forEach(light => {
                            light.light.intensity *= 1.5;
                        });
                    }
                });

                characterCanvas.addEventListener('mouseleave', function() {
                    if (!character) return;
                    if (isHovering) {
                        isHovering = false;
                        // 元のサイズに戻す
                        character.scale.multiplyScalar(1/1.05);
                        // 輝度を戻す
                        cyberLights.forEach(light => {
                            light.light.intensity /= 1.5;
                        });
                    }
                });

                // GLTFモデルのロード（ラッピングでエラーハンドリングを改善）
                try {
                    // LoadingManagerを作成してURLのリマップと進捗状況の管理を行う
                    const manager = new THREE.LoadingManager();
                    manager.setURLModifier(function(url) {
                        console.log('リクエストされたURL:', url);

                        // テクスチャファイルのパスを修正
                        if (url.endsWith('.png') && !url.includes('/')) {
                            // テクスチャファイルが参照されている場合、charactersディレクトリ内を探す
                            const fixedUrl = 'characters/' + url;
                            console.log('テクスチャファイルのパスを修正:', fixedUrl);
                            return fixedUrl;
                        }

                        return url;
                    });

                    manager.onError = function(url) {
                        console.error('リソースの読み込みに失敗しました:', url);
                    };

                    // テクスチャのデコードエラーを処理するためのキャッシュ設定
                    THREE.Cache.enabled = true;

                    const loader = new THREE.GLTFLoader(manager);

                    // デバッグのためにリクエストされるパスをログに出力
                    console.log('モデルのロード開始: characters/Animation_Dancing_withSkin.gltf');

                    loader.load('characters/Animation_Dancing_withSkin.gltf', function(gltf) {
                        console.log('GLTFモデルの読み込み成功:', gltf);
                        character = gltf.scene;

                        // テクスチャエラーを防ぐためにマテリアルを処理
                        character.traverse(function(node) {
                            if (node.isMesh && node.material) {
                                // テクスチャを適用する
                                if (Array.isArray(node.material)) {
                                    node.material.forEach(material => {
                                        // テクスチャを有効にする
                                        if (material.map) material.map.needsUpdate = true;
                                        if (material.normalMap) material.normalMap.needsUpdate = true;
                                        if (material.roughnessMap) material.roughnessMap.needsUpdate = true;
                                        if (material.metalnessMap) material.metalnessMap.needsUpdate = true;
                                        material.needsUpdate = true;
                                    });
                                } else {
                                    // テクスチャを有効にする
                                    if (node.material.map) node.material.map.needsUpdate = true;
                                    if (node.material.normalMap) node.material.normalMap.needsUpdate = true;
                                    if (node.material.roughnessMap) node.material.roughnessMap.needsUpdate = true;
                                    if (node.material.metalnessMap) node.material.metalnessMap.needsUpdate = true;
                                    node.material.needsUpdate = true;
                                }
                            }
                        });

                        // モデルのスケールと位置調整
                        character.scale.set(1.5, 1.5, 1.5);
                        character.position.set(0, 0, 0);

                        // 影の設定
                        character.traverse(function(child) {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });

                        // アニメーションの設定
                        characterMixer = new THREE.AnimationMixer(character);

                        // すべてのアニメーションクリップを取得してループ再生
                        if (gltf.animations && gltf.animations.length > 0) {
                            console.log('アニメーション数:', gltf.animations.length);

                            // 各アニメーションのデバッグ情報
                            gltf.animations.forEach((anim, index) => {
                                console.log(`アニメーション[${index}]:`, anim.name, anim.duration);
                            });

                            try {
                                const action = characterMixer.clipAction(gltf.animations[0]);
                                action.setLoop(THREE.LoopRepeat);
                                action.play();
                                console.log('アニメーション再生開始');
                            } catch (animError) {
                                console.error('アニメーション再生エラー:', animError);
                            }
                        } else {
                            console.log('アニメーションが見つかりません');
                        }

                        // キャラクターを270度回転させる
                        character.rotation.y = Math.PI * 1.5; // 270度回転

                        // シーンに追加
                        characterScene.add(character);

                        // キャラクターへのサイバーカラーの適用
                        character.traverse(function(child) {
                            if (child.isMesh && child.material) {
                                // マテリアルを複製して各メッシュのマテリアルを独立させる
                                if (Array.isArray(child.material)) {
                                    child.material = child.material.map(m => m.clone());
                                } else {
                                    child.material = child.material.clone();

                                    // エミッシブ効果でサイバー感を強化
                                    child.material.emissive = new THREE.Color(0x2a0040);
                                    child.material.emissiveIntensity = 0.2;

                                    // ハイライトを強調
                                    if (child.material.shininess !== undefined) {
                                        child.material.shininess = 60;
                                    }
                                }
                            }
                        });
                    },
                    // 進行状況
                    function(xhr) {
                        if (xhr.lengthComputable) {
                            console.log((xhr.loaded / xhr.total * 100) + '% キャラクターモデル読み込み完了');
                        } else {
                            console.log('キャラクターモデル読み込み中... ' + xhr.loaded + ' bytes');
                        }
                    },
                    // エラー処理
                    function(error) {
                        console.error('キャラクターモデル読み込みエラー:', error);

                        // エラー発生時にシンプルな代替オブジェクトを表示
                        createFallbackCharacter();
                    });
                } catch (e) {
                    console.error('GLTFLoaderの初期化に失敗しました:', e);

                    // 初期化失敗時にもフォールバックキャラクターを作成
                    createFallbackCharacter();
                }

                // フォールバック用のシンプルなキャラクター作成
                function createFallbackCharacter() {
                    try {
                        console.log('フォールバックキャラクターを作成します');

                        // シンプルな幾何学形状を作成
                        const geometry = new THREE.BoxGeometry(1, 2, 1);
                        const material = new THREE.MeshStandardMaterial({
                            color: 0x00ffff,
                            emissive: 0x2a0040,
                            emissiveIntensity: 0.5,
                            metalness: 0.7,
                            roughness: 0.2
                        });

                        character = new THREE.Mesh(geometry, material);
                        character.scale.set(0.5, 0.5, 0.5);
                        character.position.set(0, 0, 0);

                        // シーンに追加
                        characterScene.add(character);

                        // 簡易アニメーションを追加
                        const clock = new THREE.Clock();
                        const customAnimation = function() {
                            if (character) {
                                const time = clock.getElapsedTime();
                                character.rotation.y += 0.01;
                                character.position.y = Math.sin(time * 2) * 0.1;
                            }
                        };

                        // アニメーションループを更新
                        const originalAnimate = animateCharacter;
                        animateCharacter = function() {
                            requestAnimationFrame(animateCharacter);
                            customAnimation();
                            characterRenderer.render(characterScene, characterCamera);
                        };

                        // アニメーション開始
                        animateCharacter();
                    } catch (fallbackError) {
                        console.error('フォールバックキャラクター作成エラー:', fallbackError);
                    }
                }

                // ウィンドウリサイズ時の処理
                window.addEventListener('resize', function() {
                    characterCamera.aspect = window.innerWidth / window.innerHeight;
                    characterCamera.updateProjectionMatrix();
                    characterRenderer.setSize(window.innerWidth, window.innerHeight);
                });

                // キャラクターアニメーションループ
                function animateCharacter() {
                    requestAnimationFrame(animateCharacter);

                    const delta = characterClock.getDelta();
                    const time = characterClock.getElapsedTime();

                    // ミキサーの更新
                    if (characterMixer) {
                        characterMixer.update(delta);
                    }

                    // キャラクターが存在する場合、少し回転させる
                    //if (character) {
                    //    character.rotation.y += 0.002; // ゆっくり回転させる
                    //}

                    // サイバーライトをアニメーション
                    if (cyberLights && cyberLights.length > 0) {
                        cyberLights.forEach((lightObj, index) => {
                            // 強度のパルスアニメーション
                            lightObj.light.intensity = 1 + Math.sin(time * 2 + index) * 0.5;

                            // 位置のアニメーション
                            const angle = time * 0.8 + index * Math.PI * 0.5;
                            const radius = 1.5;
                            lightObj.light.position.x = Math.sin(angle) * radius;
                            lightObj.light.position.y = 1.5 + Math.cos(angle * 0.7) * 0.5;
                            lightObj.light.position.z = 3 + Math.sin(time * 0.5 + index) * 0.5;

                            // 色相のアニメーション
                            const hue = (time * 0.1 + lightObj.hueOffset) % 1;
                            const color = new THREE.Color();
                            color.setHSL(hue, 1, 0.5);
                            lightObj.light.color = color;
                        });
                    }

                    // レンダリング
                    characterRenderer.render(characterScene, characterCamera);
                }

                // アニメーション開始
                animateCharacter();
            } catch (error) {
                console.error('キャラクターアニメーション初期化エラー:', error);
            }
        }
    </script>
</body>
</html>